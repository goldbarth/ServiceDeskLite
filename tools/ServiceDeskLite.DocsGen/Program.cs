using System.Text;
using System.Text.RegularExpressions;

var repoRoot = FindRepoRoot(AppContext.BaseDirectory);

var docsRoot = Path.Combine(repoRoot, "docs");
var structureDir = Path.Combine(docsRoot, "structure");
var adrDir = Path.Combine(docsRoot, "adr");

Directory.CreateDirectory(structureDir);
Directory.CreateDirectory(adrDir);

GenerateAdrIndex(adrDir);
UpdateProjectStructureBetweenMarkers(repoRoot, structureDir);

Console.WriteLine("DocsGen: done.");

static string FindRepoRoot(string startDir)
{
    var dir = new DirectoryInfo(startDir);

    while (dir is not null)
    {
        if (Directory.Exists(Path.Combine(dir.FullName, ".git")))
            return dir.FullName;

        dir = dir.Parent;
    }

    throw new InvalidOperationException("DocsGen: Could not locate repository root (missing .git).");
}

static void GenerateAdrIndex(string adrDir)
{
    var indexPath = Path.Combine(adrDir, "index.md");

    var adrFiles = Directory.EnumerateFiles(adrDir, "*.md", SearchOption.TopDirectoryOnly)
        .Where(p => !string.Equals(Path.GetFileName(p), "index.md", StringComparison.OrdinalIgnoreCase))
        .OrderBy(Path.GetFileName, StringComparer.OrdinalIgnoreCase)
        .ToList();

    var sb = new StringBuilder();
    sb.AppendLine("<!-- This file is auto-generated. Do not edit manually. -->");
    sb.AppendLine("# ADR Index");
    sb.AppendLine();
    sb.AppendLine("| ADR | Title |");
    sb.AppendLine("|---:|---|");

    if (adrFiles.Count == 0)
    {
        sb.AppendLine("| — | _No ADRs yet._ |");
    }
    else
    {
        foreach (var file in adrFiles)
        {
            var fileName = Path.GetFileName(file);
            var title = ExtractFirstHeading(file) ?? fileName;
            var number = ExtractAdrNumber(fileName);

            sb.AppendLine($"| {number} | [{EscapeMd(title)}]({fileName}) |");
        }
    }

    WriteUtf8NoBom(indexPath, sb.ToString());
}

static void UpdateProjectStructureBetweenMarkers(string repoRoot, string structureDir)
{
    var path = Path.Combine(structureDir, "project-structure.md");
    if (!File.Exists(path))
        throw new FileNotFoundException("DocsGen: missing docs/structure/project-structure.md", path);

    var text = File.ReadAllText(path, Encoding.UTF8);

    const string begin = "<!-- AUTOGENERATED:BEGIN -->";
    const string end = "<!-- AUTOGENERATED:END -->";

    var beginIdx = text.IndexOf(begin, StringComparison.Ordinal);
    var endIdx = text.IndexOf(end, StringComparison.Ordinal);

    if (beginIdx < 0 || endIdx <= beginIdx)
        throw new InvalidOperationException("DocsGen: AUTOGENERATED markers not found in project-structure.md.");

    var generated = BuildProjectStructureMarkdown(repoRoot);

    var before = text[..(beginIdx + begin.Length)];
    var after = text[endIdx..];

    var updated = new StringBuilder();
    updated.Append(before);
    updated.AppendLine();
    updated.AppendLine();
    updated.AppendLine(generated.TrimEnd());
    updated.AppendLine();
    updated.AppendLine();
    updated.Append(after.TrimStart());

    WriteUtf8NoBom(path, updated.ToString());
}

static string BuildProjectStructureMarkdown(string repoRoot)
{
    var sb = new StringBuilder();

    sb.AppendLine("<!-- This section is auto-generated. Do not edit manually. -->");
    sb.AppendLine();
    sb.AppendLine("## Repository Structure");
    sb.AppendLine();
    sb.AppendLine("```text");

    var rootDir = new DirectoryInfo(repoRoot);

    // Only include relevant root folders
    var allowedRootFolders = new[]
    {
        "src",
        "tests",
        "tools",
        "docs",
        ".github"
    };

    var entries = rootDir.EnumerateFileSystemInfos()
        .Where(e =>
            allowedRootFolders.Contains(e.Name) ||
            e.Name.EndsWith(".sln", StringComparison.OrdinalIgnoreCase) ||
            e.Name.EndsWith(".slnx", StringComparison.OrdinalIgnoreCase) ||
            e.Name.Equals("Directory.Build.props", StringComparison.OrdinalIgnoreCase) ||
            e.Name.Equals("global.json", StringComparison.OrdinalIgnoreCase))
        .OrderBy(e => e is DirectoryInfo ? 0 : 1)
        .ThenBy(e => e.Name, StringComparer.OrdinalIgnoreCase)
        .ToList();

    for (int i = 0; i < entries.Count; i++)
    {
        var isLast = i == entries.Count - 1;
        AppendTreeNode(sb, entries[i], "", isLast);
    }

    sb.AppendLine("```");

    return sb.ToString();
}

static void AppendTreeNode(StringBuilder sb, FileSystemInfo node, string indent, bool isLast)
{
    var connector = isLast ? "└── " : "├── ";
    sb.AppendLine($"{indent}{connector}{node.Name}");

    if (node is DirectoryInfo dir)
    {
        var children = dir.EnumerateFileSystemInfos()
            .Where(e => !ShouldSkip(e))
            .OrderBy(e => e is DirectoryInfo ? 0 : 1)
            .ThenBy(e => e.Name, StringComparer.OrdinalIgnoreCase)
            .ToList();

        var childIndent = indent + (isLast ? "    " : "│   ");

        for (int i = 0; i < children.Count; i++)
        {
            AppendTreeNode(sb, children[i], childIndent, i == children.Count - 1);
        }
    }
}

static bool ShouldSkip(FileSystemInfo e)
{
    var name = e.Name;

    if (name.Equals("bin", StringComparison.OrdinalIgnoreCase)) return true;
    if (name.Equals("obj", StringComparison.OrdinalIgnoreCase)) return true;
    if (name.Equals(".git", StringComparison.OrdinalIgnoreCase)) return true;
    if (name.Equals(".idea", StringComparison.OrdinalIgnoreCase)) return true;
    if (name.Equals(".claude", StringComparison.OrdinalIgnoreCase)) return true;
    if (name.Equals(".vs", StringComparison.OrdinalIgnoreCase)) return true;
    if (name.Equals("_site", StringComparison.OrdinalIgnoreCase)) return true;

    return false;
}

static string? ExtractFirstHeading(string filePath)
{
    foreach (var line in File.ReadLines(filePath))
    {
        if (line.StartsWith("# "))
            return line[2..].Trim();
    }

    return null;
}

static string ExtractAdrNumber(string fileName)
{
    var m = MyRegex().Match(fileName);
    return m.Success ? m.Groups["n"].Value : "—";
}

static string EscapeMd(string s) => s.Replace("|", "\\|");

static void WriteUtf8NoBom(string path, string content)
{
    File.WriteAllText(path, content, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));
}

partial class Program
{
    [GeneratedRegex(@"^(?<n>\d{4})-")]
    private static partial Regex MyRegex();
}
